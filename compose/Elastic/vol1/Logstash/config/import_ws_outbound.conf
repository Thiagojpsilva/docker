input { 
 beats {
    port => 5040 
  }
}                  
	# 	 stdin {          
	#     codec => json {}
	#    }                                              
filter {

  if [message] =~ '^.*(EAITransport).*(O conversor de transporte EAI foi inicializado).*$' {
      
    # Preparando o log para retirar as informações de data.
    mutate {
     gsub => [
      "message","\tEnviando Request","Enviando Request",
      "message","\t(.*?)?HTTP response Headers from Data Send request:","HTTP response Headers from Data Send request:"
             ]
    }
    
    # Extrair a data do request e response da interface. 
    ruby { 
   	  code => 
	    '
        matches = event.get("message")
	      Request = matches.scan(/((?>\d\d){1,2}-(?:0?[1-9]|1[0-2])-(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\s[0-9]+:[0-9]+:[0-9]+)Enviando Request/)
   	    event.set("data_request",Request[0][0])
    '
		}

    # Data de Retorno. 
    ruby { 
   	code => 
      	'
        matches = event.get("message")
        Response = matches.scan(/((?>\d\d){1,2}-(?:0?[1-9]|1[0-2])-(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\s[0-9]+:[0-9]+:[0-9]+)(.*?)HTTP response Body from Data Send request(.*?)/)
        event.set("data_response",Response[0][0])
        '
				}


    # Preparando o Log para realizar a separação dos Field.
     if [type] =~ '^.*siebel8.*' {  
        mutate {
          gsub => [
          "message", "(EAITransport(.*?):0\t(?>\d\d){1,2}-(?:0?[1-9]|1[0-2])-(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\s[0-9]+:[0-9]+:[0-9]+)", "!",
          "message", "Request URL","Request_URL",
          "message", "\r\n"," !",
          "message", "\n"," !",
          "message", "\t","",
          "message", " =","=",
          "message", "=",":",
          "message", "!EAITransport(.*?):","Response_Code:",
          "message", "\|",":",
          "message", "!HTTP","HTTP",
          "message", "!Created Request Connection(.*?)=.","",
          "message", "!Enviando Request","",     
          "message", "utf","UTF"
       ]
      }
    }
    else {
         mutate {
          gsub => [
          "message", '.SOAPAction:' , '!SOAPAction:|',
          "message", ' "','',
          "message", "(EAITransport(.*?):0\t(?>\d\d){1,2}-(?:0?[1-9]|1[0-2])-(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])\s[0-9]+:[0-9]+:[0-9]+)", "!",
          "message", "Request URL","Request_URL",
          "message", "\r\n"," !",
          "message", "\n"," !",
          "message", "\t","",
          "message", " =","=",
          "message", "=",":",
          "message", "\|",":",
          "message", "!Created Request Connection(.*?)=.","",
          "message", "!Enviando Request","",     
          "message", "utf","UTF",
          "message", "\*\*\*","",
          "message", "\*\*","!",
          "message", "\*","!",
          "message", "!HTTP","HTTP",
          "message", "HTTP request Headers for Data Send Request!","",
          "message", "!EAITransport(.*?):","Response_Code:"
          ]
         }
    }

    # Gerando os Field e Valores. Key and Values
    kv{ 
      source => "message"
      field_split => "!"
      value_split => ":"
      trim_key => " "
      trim_value => " "
      allow_duplicate_values => false
      remove_field => ["Created Request Connection","Destroyed Request Connection","message"]
    }

   #Tratamento dos dados    
    mutate {
      gsub => ["SOAPAction","^.","",
      "SOAPAction",".$",""]
    }

    grok {
      match => {"Response_Code"=>"%{SYSLOGPROG:http_version} %{INT:Cod_Retorno} %{GREEDYDATA:Cod_Descricao}"}
    }

    mutate {
      convert => {
      "Sent Request" => "integer"
      }
    }
    
   #Tranformar datas retorno (Transformação ignorada)

   #  mutate {
   #  gsub => [
   #    "Date","(.*?)?, ","",
   #    "Date"," GMT",""
   # ]
   # }

   # ruby { code => "event.set('Date_2', Date.strptime(event.get('Date'), '%d %b %Y').strftime('%Y-%m-%d'))" 
   # }

   # ruby { 
   #   code => 
   #   '
   #    matches = event.get("Date")
   #    Hora = matches.scan(/[0-9]+:[0-9]+:[0-9]+/)
   #    event.set("Hora",Hora[0])
   #    '
   # }

    mutate{
    # add_field => {
    #   "data_response" => "%{Date_2} %{Hora}"
    # }
     remove_field => ["Date"]
   }
    
   #Tranformar formato das datas
    date {
       match => ["data_response", "yyyy-MM-dd HH:mm:ss"]
       target => "data_response"
     #timezone => "Etc/GMT"
    }
    
    date {
     #timezone => "Etc/GMT+3"
       match => ["data_request", "yyyy-MM-dd HH:mm:ss"]
       target => "@timestamp"
       remove_field => ["data_request"]
    }
  
  }   
    else {
      drop {}
    }
}

output {
    elasticsearch {
        hosts => ["es01:9200"]
        manage_template => false
        index => "%{type}-%{+YYYY.MM}"
        #ssl_certificate_verification => true
        #cacert => '/webtools/elastic/config/certs/CA-ROOT-Oi.crt'
        #user => logstash_writer
        #password => "${logstash_writer_pwd}"
    }
  #  stdout {
  #    codec => rubydebug
	#	}
}
